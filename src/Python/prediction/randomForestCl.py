import pickle
import os

from sklearn.ensemble import RandomForestClassifier
import sklearn.tree as sklTree

__all__ = ["train_rf_classifier", "query_rf_classifier", "forest_to_java_code"]

__current_working__dir = os.path.dirname(os.path.abspath(__file__))
rf_classifier_output = os.path.join(__current_working__dir,'lr_classifier.pkl')


""" Trains a random forest classifier and pickles the final model.

:param features_training    ->  training features
:param labels_training      ->  training labels

:return                     ->  classifier model
"""
def train_rf_classifier(features_training, labels_training):
    classifier = RandomForestClassifier(n_estimators=1500, random_state=73, max_depth=10)
    classifier.fit(features_training, labels_training)
    with open(rf_classifier_output, 'wb') as file:
        pickle.dump(classifier, file)
    return classifier


""" Queries the random forest classifier and returns predicted labels.

:param rfclass          ->  instance of a random forest classifier
:param labels_training  ->  training labels

:return                 ->  predicted labels
"""
def query_rf_classifier(rfclass, features_testing):
    labels_predicted = rfclass.predict(features_testing)
    return labels_predicted


""" Converts a random forest model to Java code.

:param forest           ->  instance of a random forest classifier
:param feature_names    ->  list of features known to the model
:param filepath         ->  Java output location
:param classname        ->  Java class
"""
def forest_to_java_code(forest, feature_names, filepath, classname):
    print("Generating Java Forest File", classname)
    with open(filepath, 'w') as file:
        estimators_ = forest.estimators_
        file.write("// THIS FILE WAS AUTOMATICALLY GENERATED BY 'src/Python/decision_tree/decision_tree.py'\n\n")
        file.write("package level_selection.model_representation;\n\n")
        file.write("public class " + classname + " {\n")
        file.write("public static int[] predict({}){{\n".format(", ".join(['int ' + f for f in feature_names])))
        # TODO: for Regressor we only have one predicition, make adaptive for Classifier
        file.write("\tlong predictions = 0L;\n")
        file.write("\tfor(int i = 0; i < {}; i++){{\n".format(len(estimators_)))
        file.write("\t\tpredictions += decisionTrees(i, {})[0];\n".format(", ".join(feature_names)))
        file.write("\t}}\n\tpredictions /= {};\n".format(len(estimators_)))
        file.write("\treturn new int[] {(int)predictions};\n}\n")

        file.write(
            "public static int[] decisionTrees(int i, {}){{\n".format(", ".join(['int ' + f for f in feature_names])))
        file.write("\tswitch(i){\n")
        for i in range(len(estimators_)):
            file.write("\tcase {}: return decisionTree{}({});\n".format(i, i, ", ".join(feature_names)))
        file.write("\tdefault : return new int[] {0};\n")
        file.write("\t}\n}\n")

        # Todo: execute function which calculates the mean
        for j, decision_tree in enumerate(estimators_):
            tree_ = decision_tree.tree_
            feature_name = [
                feature_names[i] if i != sklTree._tree.TREE_UNDEFINED else "undefined!"
                for i in tree_.feature
            ]

            file.write("private static int[] decisionTree{}({}) {{\n".format(j, ", ".join(
                ['int ' + f for f in feature_names])))

            def recurse(node, depth):
                indent = "\t" * depth
                if tree_.feature[node] != sklTree._tree.TREE_UNDEFINED:
                    name = feature_name[node]
                    threshold = tree_.threshold[node]
                    file.write("{}if ({} <= {}){{\n".format(indent, name, threshold))
                    recurse(tree_.children_left[node], depth + 1)
                    file.write("{}}}else  /* if {} > {}*/{{\n".format(indent, name, threshold))
                    recurse(tree_.children_right[node], depth + 1)
                    file.write("{}}}\n".format(indent))
                else:
                    file.write("{}return new int[] {{{}}};\n".format(indent, ','.join(
                        [str(int(round(i))) for i in list(tree_.value[node][0])])))

            recurse(0, 1)
            file.write("}\n")
        file.write("}")